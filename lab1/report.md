# 练习1：理解内核启动中的程序入口操作

## 1. 内核启动概述

在启动内核前，我们需要完成内核的内存布局和入口点设置，这需要：
- 把操作系统加载到内存里
- 规范各区域（.text, .data等）的内存地址范围  
- 明确内核的入口点，类似C程序里的main

## 2. 加载机制

把操作系统加载到内存里不可能由操作系统自己负责，需要由其它程序完成，这个程序在完成"把操作系统加载到内存"后便把CPU控制权交给操作系统。

在QEMU模拟的RISC-V计算机里：
- QEMU会把作为bootloader的OpenSBI.bin被加载到物理内存以物理地址`0x80000000`开头的区域上
- 同时内核镜像os.bin被加载到以物理地址`0x80200000`开头的区域上
- OpenSBI.bin在完成任务后需要把CPU转交给os.bin，即把pc跳转到os.bin的地址

> **注意**：os.bin如果采用随机地址的话，OpenSBI.bin则不知道把pc跳转到哪里；而OpenSBI.bin采用固定位置是因为RISC-V CPU上电后的第一条指令地址是`0x80000000`，如果OpenSBI不在此地址，CPU无法启动执行。

需要解释的是由于这是QEMU模拟的RISC-V计算机不是真正的计算机，这里的OpenSBI.bin本身不直接加载os.bin，实际是QEMU同时将OpenSBI.bin和os.bin加载到各自固定地址，OpenSBI更像"中间人"而非加载器。

## 3. 文件格式与链接过程

上面提到的bin文件需要由内存布局合适的elf文件通过objcopy转化，可以理解为：
- elf是"压缩包"而bin是"解压文件"
- 两者都是可执行文件，但前者需要在完整的操作系统上执行，而后者可以在底层固件上直接运行

我们需要的是得到内存布局合适的elf文件后交由objcopy转化再加载。

通过编译原理我们知道，可执行文件需要由源代码编译为.o文件再通过链接器转化为可执行文件，链接器会根据链接脚本把.o文件里的section映射到elf文件的section同时规定入口点和内存布局。

## 4. 入口点设置

在实验代码给定的链接脚本里规定了入口点为`kern_entry`以及内存布局，以.text为例，规定入口点在最前，之后由合并的其它代码段组成，接下来我们还需要设置入口点。

首先在entry.S中，使用`.globl`将`kern_entry`声明为全局符号，其他文件（如链接脚本）可以引用它。

`la sp, bootstacktop`：将`bootstacktop`这个符号所代表的内核栈顶部的位置加载到栈指针寄存器`sp`中。

entry.S中，`bootstack`是一块内存区域的开始（低地址），`bootstacktop`是这块区域的结束（高地址）。将`sp`设置为`bootstacktop`，正好符合栈从高向低生长的约定以及为之后跳转到`kern_init`做准备。

`tail kern_init`：跳转到`kern_init`所在的地址去执行，与标准的函数调用指令`jal`不同，`tail`用于尾调用优化，是一个函数的最后一条指令，可以理解为"我去调用那个函数，但你不必返回到我这里来了"。

跳转之后操作系统便进入了C语言的环境下，标志将CPU的执行流正式交给了操作系统的C语言主程序。

整体来看la sp, bootstacktop负责搭建栈为C函数调用做准备，tail kern_init则负责转移cpu的操控权，使用tail表示在正常运行中这次转移是彻底的，不需要考虑返回。
