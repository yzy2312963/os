# 练习1：理解内核启动中的程序入口操作

## 1. 内核启动概述

在启动内核前，我们需要完成内核的内存布局和入口点设置，这需要：
- 把操作系统加载到内存里
- 规范各区域（.text, .data等）的内存地址范围  
- 明确内核的入口点，类似C程序里的main

## 2. 加载机制

把操作系统加载到内存里不可能由操作系统自己负责，需要由其它程序完成，这个程序在完成"把操作系统加载到内存"后便把CPU控制权交给操作系统。

在QEMU模拟的RISC-V计算机里：
- QEMU会把作为bootloader的OpenSBI.bin被加载到物理内存以物理地址 0x80000000 开头的区域上
- 同时内核镜像os.bin被加载到以物理地址 0x80200000 开头的区域上
- OpenSBI.bin在完成任务后需要把CPU转交给os.bin，即把pc跳转到os.bin的地址

> **注意**：os.bin如果采用随机地址的话，OpenSBI.bin则不知道把pc跳转到哪里；而OpenSBI.bin采用固定位置是因为RISC-V CPU上电后的第一条指令地址是 0x80000000 ，如果OpenSBI不在此地址，CPU无法启动执行。

需要解释的是由于这是QEMU模拟的RISC-V计算机不是真正的计算机，这里的OpenSBI.bin本身不直接加载os.bin，实际是QEMU同时将OpenSBI.bin和os.bin加载到各自固定地址，OpenSBI更像"中间人"而非加载器。

## 3. 文件格式与链接过程

上面提到的bin文件需要由内存布局合适的elf文件通过objcopy转化，可以理解为：
- elf是"压缩包"而bin是"解压文件"
- 两者都是可执行文件，但前者需要在完整的操作系统上执行，而后者可以在底层固件上直接运行

我们需要的是得到内存布局合适的elf文件后交由objcopy转化再加载。

通过编译原理我们知道，可执行文件需要由源代码编译为.o文件再通过链接器转化为可执行文件，链接器会根据链接脚本把.o文件里的section映射到elf文件的section同时规定入口点和内存布局。

## 4. 入口点设置

在实验代码给定的链接脚本里规定了入口点为 kern_entry 以及内存布局，以.text为例，规定入口点在最前，之后由合并的其它代码段组成，接下来我们还需要设置入口点。

首先在entry.S中，使用 .globl 将 kern_entry 声明为全局符号，其他文件（如链接脚本）可以引用它。

la sp, bootstacktop ：将 bootstacktop 这个符号所代表的内核栈顶部的位置加载到栈指针寄存器 sp 中。

entry.S中， bootstack 是一块内存区域的开始（低地址）， bootstacktop 是这块区域的结束（高地址）。将 sp 设置为 bootstacktop ，正好符合栈从高向低生长的约定以及为之后跳转到 kern_init 做准备。

tail kern_init ：跳转到 kern_init 所在的地址去执行，与标准的函数调用指令 jal 不同， tail 用于尾调用优化，是一个函数的最后一条指令，可以理解为"我去调用那个函数，但你不必返回到我这里来了"。

跳转之后操作系统便进入了C语言的环境下，标志将CPU的执行流正式交给了操作系统的C语言主程序。

整体来看la sp, bootstacktop负责搭建栈为C函数调用做准备，tail kern_init则负责转移cpu的操控权，使用tail表示在正常运行中这次转移是彻底的，不需要考虑返回。
# 练习2：使用GDB验证启动流程

## 1. 硬件加电初始状态验证

通过GDB验证RISC-V硬件加电后的初始状态：

bash
(gdb) info reg pc
pc             0x1000   0x1000


**验证结果**：确认加电后PC处于0x1000，与理论描述一致。

## 2. ROM启动代码分析

查看0x1000处的启动指令：

bash
(gdb) x/5i 0x1000


输出结果：

=> 0x1000:      auipc   t0,0x0    	  # 将当前PC的高20位加载到t0，t0 = 0x1000
   0x1004:      addi    a1,t0,32     	# a1 = t0 + 32 = 0x1000 + 32 = 0x1020
   0x1008:      csrr    a0,mhartid 	  # 读取当前硬件线程ID到a0寄存器
   0x100c:      ld      t0,24(t0)     # 从内存地址(t0 + 24) = 0x1018加载64位值到t0
   0x1010:      jr      t0            # 跳转到t0寄存器指定的地址


**代码功能**：这5条指令负责从硬件固件层过渡到bootloader层。

## 3. 单步执行验证跳转地址

通过单步执行验证跳转过程：

bash
(gdb) si 5


执行后寄存器状态：

pc             0x80000000       0x80000000
t0             0x80000000       0x80000000


**验证结果**：
- PC跳转到`0x80000000`，确认控制权转移到OpenSBI.bin
- t0寄存器值为`0x80000000`，验证了跳转目标地址

## 4. OpenSBI环境状态观察

由于OpenSBI指令数量庞大，不适合单步调试，在内核入口设置断点：

bash
(gdb) b *0x80200000
(gdb) c


程序执行到断点处后，观察关键寄存器：


sp             0x8001bd80       0x8001bd80
ra             0x80000a02       0x80000a02
pc             0x80200000       0x80200000


**环境状态分析**：
- sp = 0x8001bd80：栈指针位于OpenSBI区域和内核区域之间，符合内核栈的合理位置
- ra = 0x80000a02：返回地址指向OpenSBI内部，验证了tail kern_init进行了尾调用
- pc = 0x80200000：确认控制权已转移到内核入口

## 5. 调试过程及观察结果
首先打开lab1下的终端，输入命令make debug，启动qemu。之后新建一个终端，输入命令make gdb，但出现了报错。
```
lky-os@kai-VMware-Virtual-Platform:~/桌面/labcodes/lab1$ make gdb
riscv64-unknown-elf-gdb \
    -ex 'file bin/kernel' \
    -ex 'set arch riscv:rv64' \
    -ex 'target remote localhost:1234'
make: riscv64-unknown-elf-gdb: 没有那个文件或目录
make: *** [Makefile:177：gdb] 错误 127
```
查询得知，该错误是因为系统找不到 RISC-V 64 位的 GDB 调试器。riscv64-unknown-elf-gdb 没有安装或者不在系统的 PATH 环境变量中。而先前输入命令查找时是能找到gdb的bin文件的，说明是PATH环境变量的问题。但是将工具链路径添加到 PATH 后，仍然没有解决问题，因此选择直接修改Makefile文件，在开头设置 PATH。
```
export PATH := /mnt/hgfs/share/riscv-elf-toolchains/bin:$(PATH)
```
之后执行make gdb命令，并成功连接上qemu。得到以下输出。
```
The target architecture is set to "riscv:rv64".
Remote debugging using localhost:1234
0x0000000000001000 in ?? ()
```
对内核入口的kern_entry函数下断点。
```
(gdb) b* kern_entry
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.
```
随后输入continue继续运行，但发现长时间都没有输出，直接ctrl c终止进程，发现输出：
```
Program received signal SIGINT, Interrupt.
0x0000000080000428 in ?? ()
```
可以看出程序运行在 0x80000428，这是 QEMU 的 BIOS/引导代码区域，还未运行到预期的kern_entry函数，这可能意味着内核没有被正确加载到 0x80200000。

直接强制跳转到kern_entry函数地址，遇到断点停止，看似得到了预期输出，但输入i r查询各个寄存器值时发现，所有的寄存器显示的都是0x0，表明 CPU 还没有开始执行任何代码。

之后连续多次执行continue，并ctrl c终止，发现显示的地址始终都位于BIOS 代码区域，而执行 x/10x 0x80200000，能看到内核已经正确加载到内存中，那么就说明应该是QEMU 的 BIOS 引导代码没有自动跳转到内核入口点，可能是进入了死循环。

根据大模型的建议，将Makefile中的设置进行修改，qemu目标和debug目标都需要修改：
```
# 原本的加载方式
-device loader,file=$(UCOREIMG),addr=0x80200000
# 修改后的加载方式
-kernel $(UCOREIMG) \  # 改为 -kernel 参数
```
之后重新操作实验指导书中的步骤，可以得到预期的输出。

关于这么修改的原因，可能是-kernel 参数的工作方式是QEMU 加载 OpenSBI 到 0x80000000，并告诉 OpenSBI："内核在 bin/kernel，入口点是 0x80200000"，OpenSBI 初始化后，主动跳转到 0x80200000。而-device loader 参数的工作方式是QEMU 加载 OpenSBI 到 0x80000000，并静默地把内核二进制数据拷贝到 0x80200000，OpenSBI 不知道这个操作，继续执行自己的代码，在它初始化完成后，不知道要跳转到哪里。

在continue后，成功在断点处停止：
```
(gdb) c
Continuing.

Breakpoint 1, kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
```
执行i r，也能看到各个寄存器都有了数值，而不是清一色的0x0，比如pc寄存器：
```
pc             0x80200000       0x80200000 <kern_entry>
```
以及ra (返回地址): 0x8000ae9a；sp (栈指针): 0x80046eb0 （已有初始栈）等等。同时可见RISC-V拥有大量的通用寄存器（t0-t6, a0-a7, s1-s11等）。

接着多次si单步执行，得到以下输出，可以发现开始执行的两条正是练习一中要求分析的两条指令，在这之后会进入内核初始化函数，开始清除BSS段：
```
(gdb) si
0x0000000080200004 in kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
(gdb) si
9           tail kern_init
(gdb) si
kern_init () at kern/init/init.c:8
8           memset(edata, 0, end - edata);
(gdb) si
0x000000008020000e      8           memset(edata, 0, end - edata);
(gdb) si
0x0000000080200012      8           memset(edata, 0, end - edata);
```

## 6. RISC-V 硬件加电后最初执行的几条指令的地址
### 1. CPU复位初始化 (0x1000)
```
0x0000000000001000 in ?? ()
```
0x1000是RISC-V标准的复位向量地址，这里储存着OpenSBI固件的汇编启动代码，它们负责设置最基础的CPU状态，初始化关键硬件（如中断控制器、定时器），并建立最小可用的执行环境。
### 2. SBI固件主初始化
SBI固件的主要工作有：内存控制器初始化，设备树解析，将内核镜像从存储设备加载到 0x80200000，设置内核启动参数等等。
```
(gdb) print/x *0x80200000
$1 = 0x3117
```
执行到断点处时，使用以上命令输出0x80200000的值，可以看到加载了0x3117这么一个RISC-V指令，查询得知，它是一个 auipc (Add Upper Immediate to PC) 指令的编码，这是RISC-V内核启动代码的典型第一条指令。
### 3. 控制权移交内核 (0x80200000)
内核入口点的初始任务是：设置栈指针 (la sp, bootstacktop)，为C代码执行准备运行环境，尾调用跳转到kern_init。

使用以下命令，可以得到从0x80200000开始的五条命令：
```
(gdb) x/5i 0x80200000
=> 0x80200000 <kern_entry>:     auipc   sp,0x3
   0x80200004 <kern_entry+4>:   mv      sp,sp
   0x80200008 <kern_entry+8>:   j       0x8020000a <kern_init>
   0x8020000a <kern_init>:      auipc   a0,0x3
   0x8020000e <kern_init+4>:    addi    a0,a0,-2
```
例如第一条指令Add Upper Immediate to PC，它会将立即数0x3左移12位后加到PC值，结果存入sp寄存器，计算sp = PC + (0x3 << 12) = 0x80200000 + 0x3000 = 0x80203000，这么做的目的是设置初始栈指针，指向栈区域的顶部。

以及第三条指令会无条件直接跳转到kern_init函数（C语言入口点），0x8020000a就是下一条指令的位置。

总之，根据GDB调试输出的信息，RISC-V硬件加电后最初执行的几条指令位于地址0x0000000000001000处，这个地址是RISC-V架构定义的固定复位向量地址。当CPU加电启动时，程序计数器(PC)首先指向0x1000位置，从这里开始执行初始化固件（通常是OpenSBI）的汇编代码，进行最基础的硬件初始化工作，包括设置CPU状态、初始化中断控制器和定时器等关键硬件组件，为后续加载操作系统内核建立基本的运行环境。

## 7. 主要完成的功能

可以看到，在加电到完成第一条指令的过程中，总共有三个阶段

### 第一阶段：硬件复位初始化 (0x1000)
在RISC-V框架中，0x1000被定义为标准的复位向量地址；在硬件层面来看，CPU加电或复位时，程序计数器(PC)会自动跳转到0x1000。在这个过程中，CPU核心的状态会进行初始化，包括但不限于清除所有状态寄存器和禁用所有中断。而除了CPU之外，关键的硬件组件也会进行初始化，比如中断控制器、定时器和内存管理单元等。此外，执行环境建立也发生在这个阶段，比如设置临时的栈指针，配置初始异常向量表等......

总之，这个阶段是加电后的准备阶段，目的是为了保证操作系统的正常运行与工作。

### 第二阶段：SBI固件主初始化
SBI固件主初始化是RISC-V启动过程中承上启下的关键阶段，其主要目的是在硬件基础初始化完成后，为操作系统内核的加载和执行建立完整的运行环境。其具体的行为包括如下几点：

1.建立抽象硬件层。SBI在内置的代码中提供了标准的硬件访问接口，这为不同的硬件平台提供了统一的接口，让内核无需关注底层硬件的差异。
```
// SBI提供标准化的硬件访问接口
struct sbi_platform {
    uint64_t opensbi_version;
    uint64_t platform_version;
    const char *name;
    // 硬件操作函数指针
    int (*console_putc)(char ch);
    int (*console_getc)(void);
    // 更多硬件抽象接口...
};
```
2.内存系统完整初始化。这其中又包含了时序参数设置、内存映射建立和内存检测等。形象的说，这个阶段相当于对一整个连续的内存做了基本的规划与安排。
```
0x00000000 - 0x0000FFFF: 固件代码区
0x80000000 - 0x801FFFFF: 设备映射区
0x80200000 - 0x803FFFFF: 内核加载区  
0x80400000 - 0x8FFFFFFF: 内核运行堆区
0x90000000 - 0x9FFFFFFF: 设备树和启动参数
```
(内存布局规划参考)
3.内核加载和验证。这个阶段主要是为了保护操作系统的安全，通过数字签名和HASH校验来确保内核未被篡改，也确保了内核与硬件平台的兼容。

### 第三阶段：控制权移交内核(0x80200000)
第三阶段的核心事件，就是将中央处理器的执行流，从SBI固件手中，正式移交给操作系统内核。

首先，CPU的程序计数器被设置到 0x80200000，这是RISC-V架构中约定俗成的内核入口地址。执行的第一条指令 ```aulpc sp, 0x3``` 立刻展现出了内核与固件的分离：它为内核建立了一个专属的、独立的栈空间。这个动作意义重大，因为栈是函数调用、局部变量等C代码运行的基础。内核绝不能与固件共享栈空间，否则会造成灾难性的数据混乱。

紧接着，执行流程通过一条跳转指令 ```j kern_init```进入了用C语言编写的内核主初始化函数。这条指令的执行象征了控制权的移交。从此，CPU将不再执行固件的代码，而是完全听从内核的调度。

内核在 ```kern_init``` 中，目的非常明确：从零开始，构建一个完整、自持的操作系统管理架构。不论是硬件的管理、识别与适配还是异常状态的检测与校正，自此都被装在了这个操作系统的框架中，而在这背后的是内存权限的升级——从固件运行的机器模式切换到操作系统本该拥有的监督模式。这将启用虚拟内存等强大的保护机制，确保用户程序无法直接访问硬件，从而奠定了系统安全和稳定的基石。

## 总结

### 第一部分：启动流程验证功能

通过GDB成功验证了RISC-V系统的完整启动流程：
1. **硬件加电初始化**：PC从0x1000开始执行ROM代码
2. **固件层过渡**：5条指令完成从硬件固件到bootloader的跳转准备
3. **控制权转移**：通过jr t0指令跳转到OpenSBI(0x80000000)
4. **参数传递**：OpenSBI通过寄存器向内核传递启动参数

### 第二部分：调试方法实践功能

掌握了有效的内核启动调试方法：
1. **关键断点设置**：在0x80200000设置断点避免单步海量指令
2. **寄存器状态分析**：通过观察关键寄存器验证环境设置正确性
3. **内存布局验证**：确认各组件（OpenSBI、内核栈、内核代码）位置关系合理
4. **控制流分析**：通过返回地址验证尾调用优化行为

### 实验中的重要知识点
1.linux系统的相关配置和使用。
2.GDB和Qemu配合使用完成对操作系统代码的调试，在调试中可以观察到每个阶段操作系统的行为，有利于更好的理解现代操作系统的准备过程，加深了对操作系统的认识
3.在深入研究理解每个阶段的目的与内容后，我认为课上学习的有关分页和内存管理的内容应该发生在第二阶段，对内存的划分使得操作系统在使用时更加的流畅和安全。

### 很重要但实验没提及的知识点
我们认为本实验没有涉及到很多细节方面的内容，比如对于内存管理中的很多针对于解决异常情况的算法，在实验中没有办法看到他们的运行原理。而且对于更多的操作系统在运行时的状态和改变，本实验也没有涉及。

本次练习通过GDB调试工具完整验证了从硬件加电到内核启动的全过程，确认了启动流程的理论描述与实际执行完全一致，为后续操作系统内核开发奠定了坚实的调试基础。
