练习1：理解内核启动中的程序入口操作
在启动内核前，我们需要完成内核的内存布局和入口点设置，这需要我们把操作系统加载到内存里；规范各区域（.text,.data等）的内存地址范围；明确内核的入口点，类似C程序里的mian。

把操作系统加载到内存里不可能由操作系统自己负责，需要由其它程序完成，这个程序在完成“把操作系统加载到内存“后便把cpu控制权交给操作系统，在QEMU模拟的riscv计算机里，QEMU会把作为bootloader的OpenSBI.bin被加载到物理内存以物理地址0x80000000开头的区域上，同时内核镜像os.bin被加载到以物理地址0x80200000开头的区域上，OpenSBI.bin在完成任务后需要把cpu转交给os.bin，即把pc跳转到os.bin的地址，这里 os.bin 如果采用随机地址的话 OpenSBI.bin 则不知道把pc跳转到哪里；而 OpenSBI.bin采用固定位置是因为 RISC-V CPU上电后的第一条指令地址是 ​​0x80000000​ ​，如果OpenSBI不在此地址，CPU无法启动执行。

需要解释的是由于这是QEMU模拟的riscv计算机不是真正的计算机，这里的OpenSBI.bin 本身不直接加载 os.bin​​，实际是 ​​QEMU​​ 同时将 OpenSBI.bin 和 os.bin 加载到各自固定地址，OpenSBI更像“中间人”而非加载器。

上面提到的 bin 文件需要由内存布局合适的 elf 文件通过 objcopy 转化，可以理解为 elf 是压缩包而 bin 是解压文件；两者都是可执行文件，但前者需要在完整的操作系统上执行，而后者可以在底层固件上直接运行。我们需要的是得到内存布局合适的elf文件后交由 objcopy 转化再加载。

通过编译原理我们知道，可执行文件需要由源代码编译为o文件再通过链接器转化为可执行文件，链接器会根据链接脚本把o文件里的section映射到elf文件的section同时规定入口点和内存布局。

在实验代码给定的链接脚本里规定了入口点为kern_entry以及内存布局，以.text为例，规定入口点在最前，之后由合并的其它代码段组成，接下来我们还需要设置入口点。

首先在在 entry.S中，使用 .globl 将 kern_entry声明为全局符号，其他文件（如链接脚本）可以引用它。
la sp, bootstacktop： 将 bootstacktop这个符号所代表的内核栈顶部的位置加载到栈指针寄存器 sp 中。​
entry.S 中，bootstack是一块内存区域的开始（低地址），bootstacktop是这块区域的结束（高地址）。将 sp设置为 bootstacktop，正好符合栈从高向低生长的约定以及​​为之后跳转到 kern_init做准备

tail kern_init： 跳转到kern_init所在的地址去执行，与标准的函数调用指令 jal不同，tail​​ 用于​​尾调用优化​​，是一个函数的最后一条指令，可以理解为“我去调用那个函数，但你不必返回到我这里来了”。
跳转之后操作系统便进入了C 语言的环境下，标志将 CPU 的执行流正式交给了操作系统的 C 语言主程序。

