# 练习1：理解内核启动中的程序入口操作

## 1. 内核启动概述

在启动内核前，我们需要完成内核的内存布局和入口点设置，这需要：
- 把操作系统加载到内存里
- 规范各区域（.text, .data等）的内存地址范围  
- 明确内核的入口点，类似C程序里的main

## 2. 加载机制

把操作系统加载到内存里不可能由操作系统自己负责，需要由其它程序完成，这个程序在完成"把操作系统加载到内存"后便把CPU控制权交给操作系统。

在QEMU模拟的RISC-V计算机里：
- QEMU会把作为bootloader的OpenSBI.bin被加载到物理内存以物理地址 0x80000000 开头的区域上
- 同时内核镜像os.bin被加载到以物理地址 0x80200000 开头的区域上
- OpenSBI.bin在完成任务后需要把CPU转交给os.bin，即把pc跳转到os.bin的地址

> **注意**：os.bin如果采用随机地址的话，OpenSBI.bin则不知道把pc跳转到哪里；而OpenSBI.bin采用固定位置是因为RISC-V CPU上电后的第一条指令地址是 0x80000000 ，如果OpenSBI不在此地址，CPU无法启动执行。

需要解释的是由于这是QEMU模拟的RISC-V计算机不是真正的计算机，这里的OpenSBI.bin本身不直接加载os.bin，实际是QEMU同时将OpenSBI.bin和os.bin加载到各自固定地址，OpenSBI更像"中间人"而非加载器。

## 3. 文件格式与链接过程

上面提到的bin文件需要由内存布局合适的elf文件通过objcopy转化，可以理解为：
- elf是"压缩包"而bin是"解压文件"
- 两者都是可执行文件，但前者需要在完整的操作系统上执行，而后者可以在底层固件上直接运行

我们需要的是得到内存布局合适的elf文件后交由objcopy转化再加载。

通过编译原理我们知道，可执行文件需要由源代码编译为.o文件再通过链接器转化为可执行文件，链接器会根据链接脚本把.o文件里的section映射到elf文件的section同时规定入口点和内存布局。

## 4. 入口点设置

在实验代码给定的链接脚本里规定了入口点为 kern_entry 以及内存布局，以.text为例，规定入口点在最前，之后由合并的其它代码段组成，接下来我们还需要设置入口点。

首先在entry.S中，使用 .globl 将 kern_entry 声明为全局符号，其他文件（如链接脚本）可以引用它。

la sp, bootstacktop ：将 bootstacktop 这个符号所代表的内核栈顶部的位置加载到栈指针寄存器 sp 中。

entry.S中， bootstack 是一块内存区域的开始（低地址）， bootstacktop 是这块区域的结束（高地址）。将 sp 设置为 bootstacktop ，正好符合栈从高向低生长的约定以及为之后跳转到 kern_init 做准备。

tail kern_init ：跳转到 kern_init 所在的地址去执行，与标准的函数调用指令 jal 不同， tail 用于尾调用优化，是一个函数的最后一条指令，可以理解为"我去调用那个函数，但你不必返回到我这里来了"。

跳转之后操作系统便进入了C语言的环境下，标志将CPU的执行流正式交给了操作系统的C语言主程序。

整体来看la sp, bootstacktop负责搭建栈为C函数调用做准备，tail kern_init则负责转移cpu的操控权，使用tail表示在正常运行中这次转移是彻底的，不需要考虑返回。
# 练习2：使用GDB验证启动流程

## 1. 硬件加电初始状态验证

通过GDB验证RISC-V硬件加电后的初始状态：

bash
(gdb) info reg pc
pc             0x1000   0x1000


**验证结果**：确认加电后PC处于0x1000，与理论描述一致。

## 2. ROM启动代码分析

查看0x1000处的启动指令：

bash
(gdb) x/5i 0x1000


输出结果：

=> 0x1000:      auipc   t0,0x0    	  # 将当前PC的高20位加载到t0，t0 = 0x1000
   0x1004:      addi    a1,t0,32     	# a1 = t0 + 32 = 0x1000 + 32 = 0x1020
   0x1008:      csrr    a0,mhartid 	  # 读取当前硬件线程ID到a0寄存器
   0x100c:      ld      t0,24(t0)     # 从内存地址(t0 + 24) = 0x1018加载64位值到t0
   0x1010:      jr      t0            # 跳转到t0寄存器指定的地址


**代码功能**：这5条指令负责从硬件固件层过渡到bootloader层。

## 3. 单步执行验证跳转地址

通过单步执行验证跳转过程：

bash
(gdb) si 5


执行后寄存器状态：

pc             0x80000000       0x80000000
t0             0x80000000       0x80000000


**验证结果**：
- PC跳转到`0x80000000`，确认控制权转移到OpenSBI.bin
- t0寄存器值为`0x80000000`，验证了跳转目标地址

## 4. OpenSBI环境状态观察

由于OpenSBI指令数量庞大，不适合单步调试，在内核入口设置断点：

bash
(gdb) b *0x80200000
(gdb) c


程序执行到断点处后，观察关键寄存器：


sp             0x8001bd80       0x8001bd80
ra             0x80000a02       0x80000a02
pc             0x80200000       0x80200000


**环境状态分析**：
- sp = 0x8001bd80：栈指针位于OpenSBI区域和内核区域之间，符合内核栈的合理位置
- ra = 0x80000a02：返回地址指向OpenSBI内部，验证了tail kern_init进行了尾调用
- pc = 0x80200000：确认控制权已转移到内核入口

## 总结

### 第一部分：启动流程验证功能

通过GDB成功验证了RISC-V系统的完整启动流程：
1. **硬件加电初始化**：PC从0x1000开始执行ROM代码
2. **固件层过渡**：5条指令完成从硬件固件到bootloader的跳转准备
3. **控制权转移**：通过jr t0指令跳转到OpenSBI(0x80000000)
4. **参数传递**：OpenSBI通过寄存器向内核传递启动参数

### 第二部分：调试方法实践功能

掌握了有效的内核启动调试方法：
1. **关键断点设置**：在0x80200000设置断点避免单步海量指令
2. **寄存器状态分析**：通过观察关键寄存器验证环境设置正确性
3. **内存布局验证**：确认各组件（OpenSBI、内核栈、内核代码）位置关系合理
4. **控制流分析**：通过返回地址验证尾调用优化行为

本次练习通过GDB调试工具完整验证了从硬件加电到内核启动的全过程，确认了启动流程的理论描述与实际执行完全一致，为后续操作系统内核开发奠定了坚实的调试基础。
